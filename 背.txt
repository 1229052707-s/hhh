九十九、工程化怎么管理的？
前端工程化可以自动化处理一些繁复的工作，提高开发效率，减少低级错误。
目前前端构建工具很多，综合比较来看，gulp相对来说更灵活，可以做更多的定制化任务，而webpack在模块化方面更完美一些
   gulp打造前端工程化方案，同时引入webpack来管理模块化代码，大致分工如下：
gulp：处理html压缩/预处理/条件编译，图片压缩，精灵图自动合并等任务
webpack：管理模块化，构建js/css。


一百一、git与svn的区别
git是分布式的，svn不是。
git跟svn一样有自己的集中式版本库或服务器。但git更倾向于被使用于分布式模式，克隆版本库后即使没有网络也能够commit文件，查看历史版本记录，创建项目分支等，等网络再次连接上Push到服务器端。
git把内容按元数据方式存储，而svn是按文件。
所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。
git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。
git没有一个全局的版本号，svn有。
git的内容完整性优于svn。因为git的内容存储使用的是SHA-1哈希算法。
git可以有无限个版本库，svn只能有一个指定中央版本库。
当svn中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。
每一个git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）有问题，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！


一百三、webpack打包文件太大怎么办？
webpack把我们所有的文件都打包成一个JS文件，这样即使你是小项目，打包后的文件也 会非常大。可以从去除不必要的插件，提取第三方库，代码压缩，代码分割，设置缓存几个 方面着手优化。


一百五、说说你对AMD和Commonjs的理解 
CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。
AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。



一百七、精灵图和base64如何选择？
css精灵，用于一些小的图标不是特别多，一个的体积也稍大，比如大于10K (这个没有严 格的界定）。
base64,用于小图标体积较小（相对于css精灵），多少都无所谓。字体图标，用于一些别 人做好的图标库（也有少数自己去做的）用起来比较方便，他的图标只能用于单色，图标用 只能于一种颜色。



一百一十二、移动布局自适应不同屏幕的几种方式
(1)响应式布局
(2)100%布局（弹性布局）
(3)等比缩放布局（rem)




一百一十三、请说下移动端常见的适配不同屏幕大小的方法？
响应式布局
简而言之，就是页面元素的位置随着屏幕尺寸的变化而变化，通常会用百分比来定位，而在设计上需要预留一些可被“压缩”的空间。
Cover布局
就跟background一size的cover属性一样，保持页面的宽高比，取宽或高之中的较小者占满屏幕，超出的内容会被隐藏。此布局适用于主要内容集中在中部，边沿无重要内容的设计。
Contain布局
同样，也跟background一size的contain属性那样，保持页面的宽高比，取宽或高之中的较大者占满屏幕，不足的部分会用背景填充。个人比较推荐用这种方式，但在设计上需要背景为单色，或者是可平铺的背景。



一百一十五、说说移动端是如何调试的？
移动端调试：
(1)模拟手机调试
(2)真机调试之android手机+Chrome
(3)真机调试之 iphone + safari ⑷UC浏览器
(1)微信内置浏览器调试
(2)debuggap
(3)抓包




一百二十二、浏览器http请求过多怎么解决？
(1)合并JS、CSS文件
(2)合并图片css sprite
(3)使用 Image maps
(4)data嵌入图片：如base64
(5)使用CDN，减少http请求头




一百五十三、侧滑菜单如何实现？
主要依靠两个大的容器来模拟侧滑菜单界面和主界面，把侧滑菜单放到页面右侧看不 到的地方，在操作的同时，使用css3过渡、动画或者jq来使两个容器相对运动，实现侧滑菜单效果